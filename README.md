# BNF-Wiki
A place to contain all relevant and known grammars in BNF notation.
The One Stop Shopping for all your parsing or generation needs.

## Abstract

We tried in vain to find a single website that contained a majority of
BNF listings for most common computer languages. There are many dedicated to
specific languages and BNF itself, but no one place to act as a reference and index
to all grammars.





This wiki aims to fill that need. We think that there is a wide audience for this kind of resource.

- Computer science researchers and students.
- Electronic hardware engineers.
- Artificial intelligence researchers, especially those in LP and ML fields.
- Language designers.
- Language implementers.
- Protocol specifiers.
- Standards committees .
- Security professionals.
- Quality control enginerrs.


No matter how you got here, we hope you will appreciate and contribute
to this effort. Please consider submitting missing languages, reviewing and testing  alreadyposted grammars 


## Proposed layout of the Wiki

- Home page explaining the purpose of the wiki.
  * Alphabetical index to languages by name
  * Rules for submissions
- Individual wiki page per language
  * Language name
  * Description and metadata such as version, if available.
  * BNF section
    - Optional lexical definitions
    - BNF itself
- Optional link to BNF Playground.[https://bnfplayground.pauliankline.com](https://bnfplayground.pauliankline.com)
- Optional language snippets by example
- References and citations
  * Link to wikipedia.org , if available or known.

## Backus Naur Form notation

We are aware of 3 broad types of BNF notation in the wild. Of course, there are many 
variations out there. To keep it a simple as possible here are 3 types.

- BNF: The OG type as described by John Backus and Peter Naur for the formal specification of Algol 60.
- EBNF. Extended BNF
  * Regex flavored EBNF
  * Standard EBNF
- ABNF. Augmented BNF as formalized by the IETF and used by the W3C.


We propose to encourage the use of Regex flavored EBNF because it is very human readable.
However, we acknowledge that that might always be possible. Wherever possible,
we encourage users to attempt to sprout Regex flavored EBNF pages to sublement grammars
that may not be in that category.





### Rationale

Consider the  specification of an integer in 3 BNF types:

##### Comments

We support old school C-style comments to insert inline documentation. See examples below.
This style is compatible with the BNF playground.


##### Epsilon

Epsilon which represents nothing can be represented by a capital E. Again, this is from
the BNF Playground. See example below in the OG BNF example below.

#### BNF

```BNF
/* <Integer> is defined by an optional minus sign followed by one <digit> followed  by 0 or more <digit> */
<Integer> ::= <minus_opt> <digit> <digit_ext>
/* minus_opt> is an optional <minus> */
<minus_opt> ::= E | <minus>
/* <digit_ext> is a recursive declaration */
<digit_ext> ::= E | <digit> <digit_ext>
<minus> ::= "-"
<digit> ::=  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

#### Standard EBNF

```EBNF
<Integer> ::= [<minus>] <digit> {<digit>}
/* <minus> and <digit> from the BNF example above */
```

#### Regex flavored EBNF

```EBNF
<Integer> ::= <minus>? <digit>+

/* This version of <digit>  is taken from the rules of the BNF Playground */
<digit> ::= [0-9]

/* <minus> and <digit> from the BNF example above */
```

In this example, it is clear that Regex Flavored  EBNF is more consise and readable, 
especially if you already understand Regex operator syntax.

Here is the link to the description of the type of EBNF that the BNF Playground
- [https://bnfplayground.pauliankline.com](https://bnfplayground.pauliankline.com) And click on Grammar help link.

## Terminals and lexical stuff

If your grammar is coming from a language that uses a 2 phase parser, like those
generated by either lex and yacc or flex and bison, then you might prefer
to separate terminal descriptions from nonterminals. This is because using BNF
to declare all terminals as nonterminals, like is done above in the  Integer example,
is awkward and clumsy compared to straight regular expression syntax.

Therefore, on each language wiki page is an optional Terminal definition section.

```
digit ::= /[0-9]/
integer ::= /-?[0-9]+/
```

To then refer to these terminals in the grammar part of the wiki page,
just use the lowercase terminal names as referenced in the above  Terminal section.

```EBNF
<AddExpression> ::=  integer "+" integer
<MulExpression> ::= integer "*" integer
```


## Licenses and open source

Do not copy and paste proprietary content on this wiki. Most languages
today  are open source and there should be no problem with with describing the syntax in BNF notation here.
If a language's BNF grammar is posted and we get a take down notice, it will be be
promptly be removed without notice.

This  site is covered by the Creative Commons CC0 1.0 Universal
license.

[See the LICENSE](LICENSE)



## Summary

To conclude, use Regex flavored Extended Backus Naur Form (EBNF) to specify
your grammar rules in the Grammar section. 

- Nonterminals should be  CamelCased within angle brackets.
- Terminals should be enclosed in double quotes or use lowercase identifiers referred  in the Terminal section.
- Each rule should be separated with the 'defined as' operator: '::='
- All nonterminals must have at least one starting rule definition.
- Alternative rules can either exist on their own line or be separated via the pipe operator: '|'.
- The '?' operator placed immediately after a terminal or nonterminal make that instance optional, meaning 0 or 1.
- The '*' placed immediately after a terminal or nonterminal makes that element a 0 or more repetition.
- The '+' placed immediately after a terminal or nonterminal makes that element a 1 or more repetition.
- Parenthesis can be used to group a subset of elements and operators can be used immediately after the parenthesis.

